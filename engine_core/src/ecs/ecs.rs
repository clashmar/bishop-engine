// engine_core/src/ecs/ecs.rs
use crate::ecs::component_registry::*;
use crate::ecs::position::Position;
use crate::ecs::has_any::HasAny;
use crate::ecs::component::*;
use crate::ecs::entity::*;
use serde::ser::{SerializeStruct, Serializer};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use serde::de::Deserializer;
use once_cell::sync::Lazy;
use macroquad::prelude::*;
use std::any::TypeId;
use std::any::Any;

#[derive(Default, Debug)]
pub struct Ecs {
    pub stores: HashMap<TypeId, Box<dyn Any + Send + Sync>>,
    next_entity_id: usize,
}

impl Ecs {
    /// Allocate a fresh id and return a builder.
    pub fn create_entity(&mut self) -> EntityBuilder {
        // This ensures id will always start from 1 
        self.next_entity_id += 1;
        EntityBuilder {
            id: Entity(self.next_entity_id),
            ecs: self,
        }
    }

    /// Immutable reference to a component belonging to `entity`.
    /// Returns `None` when the entity does not have that component.
    pub fn get<T>(&self, entity: Entity) -> Option<&T>
    where
        T: Component + 'static,
    {
        self.get_store::<T>().get(entity)
    }

    /// Mutable reference to a component belonging to `entity`.
    /// Panics if the component store has never been created.
    pub fn get_mut<T>(&mut self, entity: Entity) -> Option<&mut T>
    where
        T: Component + 'static,
    {
        self.get_store_mut::<T>().get_mut(entity)
    }

    /// Check whether an entity has a component of type `T`.
    pub fn has<T>(&self, entity: Entity) -> bool
    where
        T: Component + 'static,
    {
        self.get_store::<T>().contains(entity)
    }

    /// Check whether an entity has any components in tuple `T`.
    pub fn has_any<T>(&self, entity: Entity) -> bool
    where
        T: HasAny,
    {
        T::has_any(self, entity)
    }

    /// Remove an entity and all of its descendants.
    pub fn remove_entity(&mut self, entity: Entity) {
        // Detach from parent (if any)
        if let Some(parent) = self.get::<Parent>(entity).map(|p| p.0) {
            if let Some(children) = self.get_mut::<Children>(parent) {
                children.remove(entity);
                if children.entities.is_empty() {
                    self.get_store_mut::<Children>().remove(parent);
                }
            }
        }

        let children = get_children(self, entity);
        for child in children {
            self.remove_entity(child);
        }

        for reg in inventory::iter::<ComponentRegistry> {
            (reg.remove)(self, entity);
        }
    }

    /// Return an immutable reference to the store for Component `T`.
    pub fn get_store<T>(&self) -> &ComponentStore<T>
    where
        T: Component + 'static,
    {
        unsafe {
            let mut_self = self as *const Self as *mut Self;
            (*mut_self).get_or_create_store::<T>()
        }
    }

    /// Return a mutable reference, creating the store on‑first‑use.
    pub fn get_store_mut<T>(&mut self) -> &mut ComponentStore<T>
    where
        T: Component + 'static,
    {
        self.get_or_create_store::<T>()
    }

    /// Used by the `Component` impl generated by the ecs_component macro.
    pub(crate) fn get_or_create_store<T>(&mut self) -> &mut ComponentStore<T>
    where
        T: Component + 'static,
    {
        let key = TypeId::of::<ComponentStore<T>>();

        self.stores
            .entry(key)
            .or_insert_with(|| Box::new(ComponentStore::<T>::default()));

        self.stores
            .get_mut(&key)
            .unwrap()
            .downcast_mut::<ComponentStore<T>>()
            .unwrap()
    }

    pub fn insert_component<T>(&mut self, entity: Entity, component: T)
    where
        T: Component
            + Serialize
            + for<'de> Deserialize<'de>
            + Clone
            + Default
            + 'static,
    {
        // Store in the typed store (engine code can still use it directly)
        self.get_store_mut::<T>().insert(entity, component.clone());
    }

    /// Insert a component on an existing entity.
    /// If the component already exists it will be overwritten.
    pub fn add_component_to_entity<T>(&mut self, entity: Entity, component: T)
    where
        T: Component + Serialize + for<'de> Deserialize<'de> + Clone + Default + 'static,
    {
        // Store it in the typed store – the same place the engine uses directly.
        self.get_store_mut::<T>().insert(entity, component);
    }

    /// Returns the player Entity. // TODO wrap in option and move out of here
    pub fn get_player_entity(&self) -> Entity {
        // There should only ever be one player
        let player = self.get_store::<Player>().data
            .keys()
            .next()
            .expect("There should always be a player entity.");

        *player
    }

    /// Returns the player Position.
    pub fn get_player_position(&self) -> Position {
        let player_entity = self.get_player_entity();

        self.get_store::<Position>()
            .get(player_entity)
            .cloned()
            .expect("Player should always have a Position component.")
    }
}

impl Serialize for Ecs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // Build the dynamic component list
        let mut components = Vec::new();

        for (type_id, any_box) in &self.stores {
            // Find the registry entry that matches this TypeId
            let type_name = TYPE_NAME_FOR_ID.get(type_id);
            let type_name = match type_name {
                Some(name) => name,
                None => {
                    // Fallback
                    eprintln!(
                        "Skipping unknown component store (TypeId = {:?}) – \
                         it will not be saved. Add `ecs_component!` for the type to keep it.",
                        type_id
                    );
                    continue;
                }
            };
            let reg = inventory::iter::<ComponentRegistry>()
                .into_iter()
                .find(|r| r.type_name == *type_name)
                .expect("registry entry missing");

            // Convert the concrete store (`any_box`) into a RON value
            let ron_string = (reg.to_ron)(&**any_box);
            components.push(StoredComponent {
                type_name: reg.type_name.to_string(),
                data: ron_string,
            });
        }

        // Serialize the whole world
        let mut state = serializer.serialize_struct("Ecs", 2)?;
        state.serialize_field("components", &components)?;
        state.serialize_field("next_entity_id", &self.next_entity_id)?;
        state.end()
    }
}

impl<'de> Deserialize<'de> for Ecs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        // Helper struct that mirrors the data that actually writes
        #[derive(Deserialize)]
        struct Helper {
            pub components: Vec<StoredComponent>,
            pub next_entity_id: usize,
        }

        let helper = Helper::deserialize(deserializer)?;

        // Rebuild the component map
        let mut stores = HashMap::new();
        for stored in &helper.components {
            // Try to find a registry entry
            let reg_opt = inventory::iter::<ComponentRegistry>()
                .find(|r| r.type_name == stored.type_name);

            let reg = match reg_opt {
                Some(r) => r,
                None => {
                    // Unknown component
                    eprintln!(
                        "Skipping unknown component '{}' (probably removed or renamed).",
                        stored.type_name
                    );
                    continue;
                }
            };
            let any_box = (reg.from_ron)(stored.data.clone());
            let type_id = reg.type_id;
            stores.insert(type_id, any_box);
        }

        let ecs = Ecs {
            stores,
            next_entity_id: helper.next_entity_id,
        };

        Ok(ecs)
    }
}


static TYPE_NAME_FOR_ID: Lazy<HashMap<TypeId, &'static str>> = Lazy::new(|| {
    let mut map = HashMap::new();
    for reg in inventory::iter::<ComponentRegistry> {
        map.insert(reg.type_id, reg.type_name);
    }
    map
});