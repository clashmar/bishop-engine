// engine_core/src/ecs/world_ecs.rs
use std::{any::{Any, TypeId}, collections::HashMap};
use once_cell::sync::Lazy;
use crate::{
    ecs::{
        component::*, 
        component_registry::{ComponentReg, StoredComponent}, 
        entity::{Entity, EntityBuilder}
    }, 
    tiles::tile_def::{TileDef, TileDefId}
}; 
use serde::{Deserialize, Serialize};
use serde::ser::{SerializeStruct, Serializer};
use serde::de::{self, Deserializer};
use macroquad::prelude::*;


#[derive(Default)]
pub struct WorldEcs {
    pub stores: HashMap<TypeId, Box<dyn Any + Send>>,
    pub tile_defs: HashMap<TileDefId, TileDef>,
}

impl WorldEcs {
    /// Allocate a fresh UUID and return a builder.
    pub fn create_entity(&mut self) -> EntityBuilder {
        EntityBuilder {
            id: Entity::new(),
            world_ecs: self,
        }
    }

    /// Immutable reference to a component belonging to `entity`.
    /// Returns `None` when the entity does not have that component.
    pub fn get<T>(&self, entity: Entity) -> Option<&T>
    where
        T: Component + 'static,
    {
        self.get_store::<T>().get(entity)
    }

    /// Mutable reference to a component belonging to `entity`.
    /// Panics if the component store has never been created.
    pub fn get_mut<T>(&mut self, entity: Entity) -> Option<&mut T>
    where
        T: Component + 'static,
    {
        self.get_store_mut::<T>().get_mut(entity)
    }

    /// Check whether an entity has a component of type `T`.
    pub fn has<T>(&self, entity: Entity) -> bool
    where
        T: Component + 'static,
    {
        self.get_store::<T>().contains(entity)
    }

    /// Remove all component data that belongs to `entity`.
    pub fn remove_entity(&mut self, entity: Entity) {
        for reg in inventory::iter::<ComponentReg> {
            (reg.remove)(self, entity);
        }
    }

    /// Return an immutable reference to the store for Component `T`.
    pub fn get_store<T>(&self) -> &ComponentStore<T>
    where
        T: Component + 'static,
    {
        unsafe {
            let mut_self = self as *const Self as *mut Self;
            (*mut_self).get_or_create_store::<T>()
        }
    }

    /// Return a mutable reference, creating the store on‑first‑use.
    pub fn get_store_mut<T>(&mut self) -> &mut ComponentStore<T>
    where
        T: Component + 'static,
    {
        self.get_or_create_store::<T>()
    }

    /// Internal helper – used by the `Component` impl generated by the macro
    pub(crate) fn get_or_create_store<T>(&mut self) -> &mut ComponentStore<T>
    where
        T: Component + 'static,
    {
        let key = TypeId::of::<ComponentStore<T>>();

        self.stores
            .entry(key)
            .or_insert_with(|| Box::new(ComponentStore::<T>::default()));

        self.stores
            .get_mut(&key)
            .unwrap()
            .downcast_mut::<ComponentStore<T>>()
            .unwrap()
    }

    pub fn insert_component<T>(&mut self, entity: Entity, component: T)
    where
        T: Component
            + Serialize
            + for<'de> Deserialize<'de>
            + Clone
            + Default
            + 'static,
    {
        // Store in the typed store (engine code can still use it directly)
        self.get_store_mut::<T>().insert(entity, component.clone());
    }

    /// Insert a component on an existing entity.
    /// If the component already exists it will be overwritten.
    pub fn add_component_to_entity<T>(&mut self, entity: Entity, component: T)
    where
        T: Component + Serialize + for<'de> Deserialize<'de> + Clone + Default + 'static,
    {
        // Store it in the typed store – the same place the engine uses directly.
        self.get_store_mut::<T>().insert(entity, component);
    }

    /// Returns the player Entity.
    pub fn get_player_entity(&self) -> Entity {
        // There should only ever be one player
        let player = self.get_store::<Player>().data
            .keys()
            .next()
            .expect("There should always be a player entity.");

        *player
    }
}

impl Serialize for WorldEcs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // Build the dynamic component list
        let mut components = Vec::new();

        for (type_id, any_box) in &self.stores {
            // Find the registry entry that matches this TypeId
            let type_name = TYPE_NAME_FOR_ID.get(type_id);
            let type_name = match type_name {
                Some(name) => name,
                None => {
                    // Fallback
                    eprintln!(
                        "Skipping unknown component store (TypeId = {:?}) – \
                         it will not be saved. Add `ecs_component!` for the type to keep it.",
                        type_id
                    );
                    continue;
                }
            };
            let reg = inventory::iter::<ComponentReg>()
                .into_iter()
                .find(|r| r.type_name == *type_name)
                .expect("registry entry missing");

            // Convert the concrete store (`any_box`) into a RON value
            let ron_string = (reg.to_ron)(&**any_box);
            components.push(StoredComponent {
                type_name: reg.type_name.to_string(),
                data: ron_string,
            });
        }

        // Serialize the whole world
        let mut state = serializer.serialize_struct("WorldEcs", 2)?;
        state.serialize_field("components", &components)?;
        state.serialize_field("tile_defs", &self.tile_defs)?;
        state.end()
    }
}

impl<'de> Deserialize<'de> for WorldEcs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        // Helper struct that mirrors the data that actually writes
        #[derive(Deserialize)]
        struct Helper {
            pub components: Vec<StoredComponent>,
            pub tile_defs: HashMap<TileDefId, TileDef>,
        }

        let helper = Helper::deserialize(deserializer)?;

        // Re‑build the component map
        let mut stores = HashMap::new();
        for stored in &helper.components {
            let reg = inventory::iter::<ComponentReg>()
                .find(|r| r.type_name == stored.type_name)
                .ok_or_else(|| {
                    de::Error::custom(format!(
                        "unknown component type '{}'",
                        stored.type_name
                    ))
                })?;
            let any_box = (reg.from_ron)(stored.data.clone());
            let type_id = reg.type_id;
            stores.insert(type_id, any_box);
        }

        // Assemble the final world
        Ok(WorldEcs {
            stores,
            tile_defs: helper.tile_defs,
        })
    }
}


static TYPE_NAME_FOR_ID: Lazy<HashMap<TypeId, &'static str>> = Lazy::new(|| {
    let mut map = HashMap::new();
    for reg in inventory::iter::<ComponentReg> {
        map.insert(reg.type_id, reg.type_name);
    }
    map
});